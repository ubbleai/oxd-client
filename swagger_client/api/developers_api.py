# coding: utf-8

"""
    oxd-server

    oxd-server  # noqa: E501

    OpenAPI spec version: 4.0
    Contact: yuriyz@gluu.org
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DevelopersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_access_token_by_refresh_token(self, **kwargs):  # noqa: E501
        """Get Access Token By Refresh Token  # noqa: E501

        Get Access Token By Refresh Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_by_refresh_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetAccessTokenByRefreshTokenParams get_access_token_by_refresh_token_params:
        :return: GetAccessTokenByRefreshTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_token_by_refresh_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_access_token_by_refresh_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_access_token_by_refresh_token_with_http_info(self, **kwargs):  # noqa: E501
        """Get Access Token By Refresh Token  # noqa: E501

        Get Access Token By Refresh Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_token_by_refresh_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetAccessTokenByRefreshTokenParams get_access_token_by_refresh_token_params:
        :return: GetAccessTokenByRefreshTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'get_access_token_by_refresh_token_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_token_by_refresh_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_access_token_by_refresh_token_params' in params:
            body_params = params['get_access_token_by_refresh_token_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-access-token-by-refresh-token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAccessTokenByRefreshTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_authorization_url(self, **kwargs):  # noqa: E501
        """Get Authorization Url  # noqa: E501

        Gets authorization url  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorization_url(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetAuthorizationUrlParams get_authorization_url_params:
        :return: GetAuthorizationUrlResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_authorization_url_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_authorization_url_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_authorization_url_with_http_info(self, **kwargs):  # noqa: E501
        """Get Authorization Url  # noqa: E501

        Gets authorization url  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_authorization_url_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetAuthorizationUrlParams get_authorization_url_params:
        :return: GetAuthorizationUrlResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'get_authorization_url_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_authorization_url" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_authorization_url_params' in params:
            body_params = params['get_authorization_url_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-authorization-url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetAuthorizationUrlResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_client_token(self, **kwargs):  # noqa: E501
        """Get Client Token  # noqa: E501

        Gets Client Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetClientTokenParams get_client_token_params:
        :return: GetClientTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_client_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_client_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_client_token_with_http_info(self, **kwargs):  # noqa: E501
        """Get Client Token  # noqa: E501

        Gets Client Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_client_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetClientTokenParams get_client_token_params:
        :return: GetClientTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['get_client_token_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_client_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_client_token_params' in params:
            body_params = params['get_client_token_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-client-token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetClientTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_discovery(self, **kwargs):  # noqa: E501
        """Get OP Discovery Configuration  # noqa: E501

        Get OP Discovery Configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_discovery(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetDiscoveryParams get_discovery_params:
        :return: GetDiscoveryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_discovery_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_discovery_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_discovery_with_http_info(self, **kwargs):  # noqa: E501
        """Get OP Discovery Configuration  # noqa: E501

        Get OP Discovery Configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_discovery_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetDiscoveryParams get_discovery_params:
        :return: GetDiscoveryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['get_discovery_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_discovery" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_discovery_params' in params:
            body_params = params['get_discovery_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-discovery', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetDiscoveryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_json_web_key_set(self, **kwargs):  # noqa: E501
        """Get JSON Web Key Set  # noqa: E501

        Get JSON Web Key Set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_json_web_key_set(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetJwksParams get_jwks_params:
        :return: GetJwksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_json_web_key_set_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_json_web_key_set_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_json_web_key_set_with_http_info(self, **kwargs):  # noqa: E501
        """Get JSON Web Key Set  # noqa: E501

        Get JSON Web Key Set  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_json_web_key_set_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetJwksParams get_jwks_params:
        :return: GetJwksResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'get_jwks_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_json_web_key_set" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_jwks_params' in params:
            body_params = params['get_jwks_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-jwks', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetJwksResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_logout_uri(self, **kwargs):  # noqa: E501
        """Get Logout URL  # noqa: E501

        Get Logout URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logout_uri(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetLogoutUriParams get_logout_uri_params:
        :return: GetLogoutUriResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_logout_uri_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_logout_uri_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_logout_uri_with_http_info(self, **kwargs):  # noqa: E501
        """Get Logout URL  # noqa: E501

        Get Logout URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_logout_uri_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetLogoutUriParams get_logout_uri_params:
        :return: GetLogoutUriResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'get_logout_uri_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_logout_uri" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_logout_uri_params' in params:
            body_params = params['get_logout_uri_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-logout-uri', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetLogoutUriResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tokens_by_code(self, **kwargs):  # noqa: E501
        """Get Tokens By Code  # noqa: E501

        Get tokens by code  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tokens_by_code(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetTokensByCodeParams get_tokens_by_code_params:
        :return: GetTokensByCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tokens_by_code_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tokens_by_code_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_tokens_by_code_with_http_info(self, **kwargs):  # noqa: E501
        """Get Tokens By Code  # noqa: E501

        Get tokens by code  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tokens_by_code_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetTokensByCodeParams get_tokens_by_code_params:
        :return: GetTokensByCodeResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'get_tokens_by_code_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tokens_by_code" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_tokens_by_code_params' in params:
            body_params = params['get_tokens_by_code_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-tokens-by-code', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GetTokensByCodeResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user_info(self, **kwargs):  # noqa: E501
        """Get User Info  # noqa: E501

        Get User Info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetUserInfoParams get_user_info_params:
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_info_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_user_info_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_user_info_with_http_info(self, **kwargs):  # noqa: E501
        """Get User Info  # noqa: E501

        Get User Info  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_info_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param GetUserInfoParams get_user_info_params:
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'get_user_info_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user_info" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'get_user_info_params' in params:
            body_params = params['get_user_info_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/get-user-info', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def health_check(self, **kwargs):  # noqa: E501
        """Health Check  # noqa: E501

        Health Check endpoint is for quick check whether oxd-server is alive.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.health_check_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.health_check_with_http_info(**kwargs)  # noqa: E501
            return data

    def health_check_with_http_info(self, **kwargs):  # noqa: E501
        """Health Check  # noqa: E501

        Health Check endpoint is for quick check whether oxd-server is alive.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_check_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method health_check" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/health-check', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def introspect_access_token(self, **kwargs):  # noqa: E501
        """Introspect Access Token  # noqa: E501

        Introspect Access Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_access_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param IntrospectAccessTokenParams introspect_access_token_params:
        :return: IntrospectAccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.introspect_access_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.introspect_access_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def introspect_access_token_with_http_info(self, **kwargs):  # noqa: E501
        """Introspect Access Token  # noqa: E501

        Introspect Access Token  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_access_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param IntrospectAccessTokenParams introspect_access_token_params:
        :return: IntrospectAccessTokenResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'introspect_access_token_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method introspect_access_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'introspect_access_token_params' in params:
            body_params = params['introspect_access_token_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/introspect-access-token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IntrospectAccessTokenResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def introspect_rpt(self, **kwargs):  # noqa: E501
        """Introspect RPT  # noqa: E501

        Introspect RPT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_rpt(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param IntrospectRptParams introspect_rpt_params:
        :return: IntrospectRptResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.introspect_rpt_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.introspect_rpt_with_http_info(**kwargs)  # noqa: E501
            return data

    def introspect_rpt_with_http_info(self, **kwargs):  # noqa: E501
        """Introspect RPT  # noqa: E501

        Introspect RPT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_rpt_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param IntrospectRptParams introspect_rpt_params:
        :return: IntrospectRptResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'introspect_rpt_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method introspect_rpt" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'introspect_rpt_params' in params:
            body_params = params['introspect_rpt_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/introspect-rpt', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='IntrospectRptResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def register_site(self, **kwargs):  # noqa: E501
        """Register Site  # noqa: E501

        Registers site at oxd-server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_site(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegisterSiteParams register_site_params:
        :return: RegisterSiteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.register_site_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.register_site_with_http_info(**kwargs)  # noqa: E501
            return data

    def register_site_with_http_info(self, **kwargs):  # noqa: E501
        """Register Site  # noqa: E501

        Registers site at oxd-server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.register_site_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RegisterSiteParams register_site_params:
        :return: RegisterSiteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['register_site_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method register_site" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'register_site_params' in params:
            body_params = params['register_site_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/register-site', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegisterSiteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_site(self, **kwargs):  # noqa: E501
        """Remove Site  # noqa: E501

        Removes site from oxd-server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_site(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param RemoveSiteParams remove_site_params:
        :return: UpdateSiteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_site_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.remove_site_with_http_info(**kwargs)  # noqa: E501
            return data

    def remove_site_with_http_info(self, **kwargs):  # noqa: E501
        """Remove Site  # noqa: E501

        Removes site from oxd-server  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_site_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param RemoveSiteParams remove_site_params:
        :return: UpdateSiteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'remove_site_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_site" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'remove_site_params' in params:
            body_params = params['remove_site_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/remove-site', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateSiteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uma_rp_get_claims_gathering_url(self, **kwargs):  # noqa: E501
        """UMA RP Get Claims Gathering URL  # noqa: E501

        UMA RP Get Claims Gathering URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rp_get_claims_gathering_url(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRpGetClaimsGatheringUrlParams uma_rp_get_claims_gathering_url_params:
        :return: UmaRpGetClaimsGatheringUrlResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.uma_rp_get_claims_gathering_url_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.uma_rp_get_claims_gathering_url_with_http_info(**kwargs)  # noqa: E501
            return data

    def uma_rp_get_claims_gathering_url_with_http_info(self, **kwargs):  # noqa: E501
        """UMA RP Get Claims Gathering URL  # noqa: E501

        UMA RP Get Claims Gathering URL  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rp_get_claims_gathering_url_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRpGetClaimsGatheringUrlParams uma_rp_get_claims_gathering_url_params:
        :return: UmaRpGetClaimsGatheringUrlResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'uma_rp_get_claims_gathering_url_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uma_rp_get_claims_gathering_url" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'uma_rp_get_claims_gathering_url_params' in params:
            body_params = params['uma_rp_get_claims_gathering_url_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/uma-rp-get-claims-gathering-url', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UmaRpGetClaimsGatheringUrlResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uma_rp_get_rpt(self, **kwargs):  # noqa: E501
        """UMA RP Get RPT  # noqa: E501

        UMA RP Get RPT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rp_get_rpt(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRpGetRptParams uma_rp_get_rpt_params:
        :return: UmaRpGetRptResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.uma_rp_get_rpt_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.uma_rp_get_rpt_with_http_info(**kwargs)  # noqa: E501
            return data

    def uma_rp_get_rpt_with_http_info(self, **kwargs):  # noqa: E501
        """UMA RP Get RPT  # noqa: E501

        UMA RP Get RPT  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rp_get_rpt_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRpGetRptParams uma_rp_get_rpt_params:
        :return: UmaRpGetRptResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'uma_rp_get_rpt_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uma_rp_get_rpt" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'uma_rp_get_rpt_params' in params:
            body_params = params['uma_rp_get_rpt_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/uma-rp-get-rpt', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UmaRpGetRptResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uma_rs_check_access(self, **kwargs):  # noqa: E501
        """UMA RS Check Access  # noqa: E501

        UMA RS Check Access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rs_check_access(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRsCheckAccessParams uma_rs_check_access_params:
        :return: UmaRsCheckAccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.uma_rs_check_access_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.uma_rs_check_access_with_http_info(**kwargs)  # noqa: E501
            return data

    def uma_rs_check_access_with_http_info(self, **kwargs):  # noqa: E501
        """UMA RS Check Access  # noqa: E501

        UMA RS Check Access  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rs_check_access_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRsCheckAccessParams uma_rs_check_access_params:
        :return: UmaRsCheckAccessResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'uma_rs_check_access_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uma_rs_check_access" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'uma_rs_check_access_params' in params:
            body_params = params['uma_rs_check_access_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/uma-rs-check-access', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UmaRsCheckAccessResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uma_rs_protect(self, **kwargs):  # noqa: E501
        """UMA RS Protect Resources  # noqa: E501

        UMA RS Protect Resources. It's important to have a single HTTP method, mentioned only once within a given path in JSON, otherwise, the operation will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rs_protect(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRsProtectParams uma_rs_protect_params:
        :return: UmaRsProtectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.uma_rs_protect_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.uma_rs_protect_with_http_info(**kwargs)  # noqa: E501
            return data

    def uma_rs_protect_with_http_info(self, **kwargs):  # noqa: E501
        """UMA RS Protect Resources  # noqa: E501

        UMA RS Protect Resources. It's important to have a single HTTP method, mentioned only once within a given path in JSON, otherwise, the operation will fail.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uma_rs_protect_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UmaRsProtectParams uma_rs_protect_params:
        :return: UmaRsProtectResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'uma_rs_protect_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uma_rs_protect" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'uma_rs_protect_params' in params:
            body_params = params['uma_rs_protect_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/uma-rs-protect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UmaRsProtectResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_site(self, **kwargs):  # noqa: E501
        """Update Site  # noqa: E501

        Updates site at oxd-server. If something changes in a pre-registered client, you can use this API to update your client in the OP.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_site(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UpdateSiteParams update_site_params:
        :return: UpdateSiteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_site_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.update_site_with_http_info(**kwargs)  # noqa: E501
            return data

    def update_site_with_http_info(self, **kwargs):  # noqa: E501
        """Update Site  # noqa: E501

        Updates site at oxd-server. If something changes in a pre-registered client, you can use this API to update your client in the OP.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_site_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str authorization:
        :param UpdateSiteParams update_site_params:
        :return: UpdateSiteResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['authorization', 'update_site_params']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_site" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'authorization' in params:
            header_params['Authorization'] = params['authorization']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'update_site_params' in params:
            body_params = params['update_site_params']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/update-site', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdateSiteResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
